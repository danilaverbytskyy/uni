.data
 result DD 0
 A      DW 25
 B      DD 196
 C      DW 4

.code
start:
    ; ===== Арифметическая часть =====
    ; Вычисляем делитель D = 100 - C

    xor     ebx, ebx        ; EBX = 0 
    mov     bx, C           ; EBX = C (4)
    mov     ecx, 100        ; ECX = 100
    sub     ecx, ebx        ; ECX = 100 - C = 96

    ; Вычисляем частное Q = B / (100 - C)
    ; Делим двойное слово B на двойное слово (100 - C)

    mov     eax, B          ; EAX = младшие 32 бита делимого (196)
    xor     edx, edx        ; расширяем делимое до EDX:EAX (64 бита)
    div     ecx             ; Q = (EDX:EAX)/ECX. Если иничего не указать вторым регистром, то берется из eax
                            ; EAX = Q (частное), EDX = R (остаток)

    mov     esi, eax        ; ESI = Q = B/(100 - C)

    ; Вычисляем выражение A + 108 - Q

    xor     eax, eax        ; обнуляем EAX
    mov     ax, A           ; EAX = A (25), расширение до двойного слова
    add     eax, 108        ; EAX = A + 108
    sub     eax, esi        ; EAX = A + 108 - Q

    mov     result, eax     ; сохраняем арифметический результат

    ; ===== Логическая часть =====
    ; Проверка факта наличия 0 в 4-м разряде результата.
    ; Маска для бита 4: 00010000b = 10h.

    mov     eax, result     ; загружаем результат выражения
    test    eax, 10h        ; проверяем бит 4; Логическое  AND; Существуют Флаги, которые сохраняют информацию о последних операциях
		;10h h - обозначатель, что это шестн. число; 
    jz      BIT_IS_ZERO     ; если (result AND 10h) = 0 → бит 4 = 0; jump и в zero/

    ; Бит 4 равен 1 – факт наличия 0 в разряде 4 ОТСУТСТВУЕТ
    mov     result, 0
    jmp     AFTER_LOGIC

BIT_IS_ZERO:
    ; Бит 4 равен 0 – факт наличия 0 в разряде 4 ИМЕЕТСЯ
    mov     result, 1

AFTER_LOGIC:
    ; здесь могла бы быть остановка программы / выход в ОС

end start