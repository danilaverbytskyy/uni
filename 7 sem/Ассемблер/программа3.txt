.data
 A dw 1,2,3,4,5,6,7,8,9,10,
    11,12,13,14,15,16,17,18,19,20
 B dw 21,22,23,24,25,26,27,28,29,30,
    31,32,33,34,35,36,37,38,39,40

.code
start:
    mov ebx, 20              ; счётчик внешнего цикла (20 обменов)

L1: ;-- поиск минимального элемента массива A[20] --;
    mov esi, offset A        ; адрес начала массива A
    mov ax, [esi]            ; текущий минимум
    mov edi, esi             ; адрес минимального элемента
    mov ecx, 19              ; осталось просмотреть ещё 19 элементов

L2:
    add esi, 2               ; переходим к следующему слову
    mov dx, [esi]            ; берём очередной элемент
    cmp dx, ax               ; сравниваем с текущим минимумом
    jge L3                   ; если новый элемент >= минимума, пропустить
    mov ax, dx               ; иначе обновляем минимум
    mov edi, esi             ; и запоминаем его адрес
L3:
    loop L2                  ; пока не просмотрены все 20 элементов

    ;-- поиск максимального элемента массива B[20] --;
    mov esi, offset B        ; адрес начала массива B
    mov dx, [esi]            ; текущий максимум
    mov ebp, esi             ; адрес максимального элемента
    mov ecx, 19

L4:
    add esi, 2               ; следующий элемент массива B
    mov ax, [esi]
    cmp ax, dx               ; сравнение с текущим максимумом
    jle L5                   ; если новый элемент <= максимума, пропустить
    mov dx, ax               ; иначе обновляем максимум
    mov ebp, esi             ; и запоминаем его адрес
L5:
    loop L4

    ;-- обмен минимального A и максимального B местами --;
    mov ax, [edi]            ; ax = минимальный элемент из A
    mov [edi], dx            ; на его место записываем максимум из B
    mov [ebp], ax            ; в массив B записываем прежний минимум из A

    ;-- уменьшение счётчика внешнего цикла --;
    dec ebx
    jnz L1                   ; повторить, пока не выполнено 20 обменов

end start
